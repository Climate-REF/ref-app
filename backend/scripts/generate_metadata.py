"""
Generate diagnostic metadata YAML from the current provider registry.

This script bootstraps or updates the metadata.yaml file by iterating all
registered diagnostics and capturing their current state (display_name,
description, tags, reference_datasets). Existing values in metadata.yaml
take precedence over auto-generated values.

Usage:
    cd backend && uv run python scripts/generate_metadata.py

Options:
    --output PATH   Write to a specific file (default: static/diagnostics/metadata.yaml)
    --dry-run       Print to stdout instead of writing to file
"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Any

import yaml

# Add the backend src to the path so we can import ref_backend
backend_dir = Path(__file__).parent.parent
sys.path.insert(0, str(backend_dir / "src"))

from ref_backend.core.config import Settings  # noqa: E402
from ref_backend.core.diagnostic_metadata import DiagnosticMetadata, load_diagnostic_metadata  # noqa: E402
from ref_backend.core.ref import get_database, get_provider_registry, get_ref_config  # noqa: E402


def _metadata_to_dict(metadata: DiagnosticMetadata) -> dict[str, Any]:
    """Convert a DiagnosticMetadata to a dict, including only non-None fields."""
    entry: dict[str, Any] = {}
    if metadata.display_name is not None:
        entry["display_name"] = metadata.display_name
    if metadata.description is not None:
        entry["description"] = metadata.description
    if metadata.tags is not None:
        entry["tags"] = metadata.tags
    if metadata.reference_datasets is not None:
        entry["reference_datasets"] = [rd.model_dump(exclude_none=True) for rd in metadata.reference_datasets]
    return entry


def _build_entry(
    key: str,
    diagnostic_slug: str,
    concrete_diagnostic: object,
    existing_metadata: dict[str, DiagnosticMetadata],
) -> dict[str, Any]:
    """Build a metadata entry for a diagnostic, merging with existing values."""
    entry: dict[str, Any] = {}

    # Use the diagnostic's display name from the class
    entry["display_name"] = getattr(concrete_diagnostic, "name", diagnostic_slug)

    # Use the docstring as description
    doc = concrete_diagnostic.__doc__
    if doc:
        entry["description"] = " ".join(doc.strip().split())

    # Merge with existing metadata: existing values take precedence
    if key in existing_metadata:
        existing = _metadata_to_dict(existing_metadata[key])
        entry.update(existing)

    return entry


def generate_metadata(output_path: Path | None = None, *, dry_run: bool = False) -> None:
    """Generate metadata.yaml from the provider registry, merging with existing values."""
    settings = Settings()
    ref_config = get_ref_config(settings)
    database = get_database(ref_config)
    provider_registry = get_provider_registry(ref_config)

    # Load existing metadata (existing values take precedence)
    default_metadata_path = backend_dir / "static" / "diagnostics" / "metadata.yaml"
    metadata_path = output_path or default_metadata_path
    existing_metadata = load_diagnostic_metadata(metadata_path)

    # Iterate all registered diagnostics
    generated: dict[str, dict[str, Any]] = {}

    with database.session.connection():
        for provider_slug, diagnostics in provider_registry.metrics.items():
            for diagnostic_slug, concrete_diagnostic in diagnostics.items():
                key = f"{provider_slug}/{diagnostic_slug}"
                generated[key] = _build_entry(key, diagnostic_slug, concrete_diagnostic, existing_metadata)

    # Also include any entries from existing metadata that weren't found in the registry
    for key, metadata in existing_metadata.items():
        if key not in generated:
            generated[key] = _metadata_to_dict(metadata)

    # Sort by key for consistent output
    sorted_metadata = dict(sorted(generated.items()))

    # Generate YAML output
    yaml_content = yaml.dump(
        sorted_metadata,
        default_flow_style=False,
        sort_keys=False,
        allow_unicode=True,
        width=120,
    )

    header = (
        "# Diagnostic Metadata\n"
        "#\n"
        "# Auto-generated by: cd backend && uv run python scripts/generate_metadata.py\n"
        "#\n"
        "# This file provides metadata for diagnostics including display names, descriptions,\n"
        "# reference datasets, and tags. Hand-edited values take precedence over auto-generated\n"
        "# values when the script is re-run.\n"
        "#\n\n"
    )

    output = header + yaml_content

    if dry_run:
        print(output)
    else:
        metadata_path.parent.mkdir(parents=True, exist_ok=True)
        metadata_path.write_text(output)
        print(f"Generated metadata written to {metadata_path}")
        print(f"Total diagnostics: {len(sorted_metadata)}")


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate diagnostic metadata YAML")
    parser.add_argument(
        "--output",
        type=Path,
        default=None,
        help="Output file path (default: static/diagnostics/metadata.yaml)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print to stdout instead of writing to file",
    )
    args = parser.parse_args()
    generate_metadata(output_path=args.output, dry_run=args.dry_run)


if __name__ == "__main__":
    main()
