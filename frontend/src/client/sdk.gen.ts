// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from '@hey-api/client-fetch';
import type { DatasetsListData, DatasetsListResponse, DatasetsListError, DatasetsGetData, DatasetsGetResponse, DatasetsGetError, DatasetsExecutionsData, DatasetsExecutionsResponse, DatasetsExecutionsError, DiagnosticsListData, DiagnosticsListResponse, DiagnosticsFacetsData, DiagnosticsFacetsResponse, DiagnosticsGetData, DiagnosticsGetResponse, DiagnosticsGetError, DiagnosticsListExecutionGroupsData, DiagnosticsListExecutionGroupsResponse, DiagnosticsListExecutionGroupsError, DiagnosticsComparisonData, DiagnosticsComparisonResponse, DiagnosticsComparisonError, DiagnosticsListExecutionsData, DiagnosticsListExecutionsResponse, DiagnosticsListExecutionsError, DiagnosticsListMetricValuesData, DiagnosticsListMetricValuesError, ExecutionsGetExecutionStatisticsData, ExecutionsGetExecutionStatisticsResponse, ExecutionsListRecentExecutionGroupsData, ExecutionsListRecentExecutionGroupsResponse, ExecutionsListRecentExecutionGroupsError, ExecutionsGetData, ExecutionsGetResponse, ExecutionsGetError, ExecutionsExecutionData, ExecutionsExecutionResponse, ExecutionsExecutionError, ExecutionsExecutionDatasetsData, ExecutionsExecutionDatasetsResponse, ExecutionsExecutionDatasetsError, ExecutionsExecutionLogsData, ExecutionsExecutionLogsError, ExecutionsMetricBundleData, ExecutionsMetricBundleResponse, ExecutionsMetricBundleError, ExecutionsMetricValuesData, ExecutionsMetricValuesError, ExecutionsExecutionArchiveData, ExecutionsExecutionArchiveError, ResultsGetResultData, ResultsGetResultError, UtilsHealthCheckData, UtilsHealthCheckResponse } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * List
 * Paginated list of currently ingested datasets
 */
export const datasetsList = <ThrowOnError extends boolean = false>(options?: Options<DatasetsListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<DatasetsListResponse, DatasetsListError, ThrowOnError>({
        url: '/api/v1/datasets/',
        ...options
    });
};

/**
 * Get
 * Get a single dataset by slug
 */
export const datasetsGet = <ThrowOnError extends boolean = false>(options: Options<DatasetsGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<DatasetsGetResponse, DatasetsGetError, ThrowOnError>({
        url: '/api/v1/datasets/{slug}',
        ...options
    });
};

/**
 * Executions
 * List the currently registered diagnostics
 */
export const datasetsExecutions = <ThrowOnError extends boolean = false>(options: Options<DatasetsExecutionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<DatasetsExecutionsResponse, DatasetsExecutionsError, ThrowOnError>({
        url: '/api/v1/datasets/{dataset_id}/executions',
        ...options
    });
};

/**
 * List
 * List the currently registered diagnostics
 */
export const diagnosticsList = <ThrowOnError extends boolean = false>(options?: Options<DiagnosticsListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<DiagnosticsListResponse, unknown, ThrowOnError>({
        url: '/api/v1/diagnostics/',
        ...options
    });
};

/**
 * Facets
 * Query the unique dimensions and metrics for all diagnostics (both scalar and series)
 */
export const diagnosticsFacets = <ThrowOnError extends boolean = false>(options?: Options<DiagnosticsFacetsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<DiagnosticsFacetsResponse, unknown, ThrowOnError>({
        url: '/api/v1/diagnostics/facets',
        ...options
    });
};

/**
 * Get
 * Fetch a result using the slug
 */
export const diagnosticsGet = <ThrowOnError extends boolean = false>(options: Options<DiagnosticsGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<DiagnosticsGetResponse, DiagnosticsGetError, ThrowOnError>({
        url: '/api/v1/diagnostics/{provider_slug}/{diagnostic_slug}',
        ...options
    });
};

/**
 * List Execution Groups
 * Fetch a result using the slug
 */
export const diagnosticsListExecutionGroups = <ThrowOnError extends boolean = false>(options: Options<DiagnosticsListExecutionGroupsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<DiagnosticsListExecutionGroupsResponse, DiagnosticsListExecutionGroupsError, ThrowOnError>({
        url: '/api/v1/diagnostics/{provider_slug}/{diagnostic_slug}/execution_groups',
        ...options
    });
};

/**
 * Comparison
 * Get all the diagnostic values for a given diagnostic, with flexible filtering.
 *
 * - `source_filters`: A JSON string representing a dictionary of filters to apply to
 * the source data. For example: `{"source_id": "MIROC6", "experiment_id": "ssp585"}`
 * - `type`: Type of metric values to compare - 'scalar' (default), 'series', or 'all'
 * - Other query parameters are treated as filters to be applied to all data before
 * being split into source and ensemble.
 */
export const diagnosticsComparison = <ThrowOnError extends boolean = false>(options: Options<DiagnosticsComparisonData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<DiagnosticsComparisonResponse, DiagnosticsComparisonError, ThrowOnError>({
        url: '/api/v1/diagnostics/{provider_slug}/{diagnostic_slug}/comparison',
        ...options
    });
};

/**
 * List Executions
 * Fetch executions for a specific diagnostic, with arbitrary filters on the dataset.
 *
 * e.g. `?source_id=MIROC6&experiment_id=ssp585`
 */
export const diagnosticsListExecutions = <ThrowOnError extends boolean = false>(options: Options<DiagnosticsListExecutionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<DiagnosticsListExecutionsResponse, DiagnosticsListExecutionsError, ThrowOnError>({
        url: '/api/v1/diagnostics/{provider_slug}/{diagnostic_slug}/executions',
        ...options
    });
};

/**
 * List Metric Values
 * Get all the diagnostic values for a given diagnostic (both scalar and series)
 *
 * - `type`: Filter by metric value type - 'scalar', 'series', or 'all' (default)
 * - `format`: Return format - 'json' (default) or 'csv'
 */
export const diagnosticsListMetricValues = <ThrowOnError extends boolean = false>(options: Options<DiagnosticsListMetricValuesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, DiagnosticsListMetricValuesError, ThrowOnError>({
        url: '/api/v1/diagnostics/{provider_slug}/{diagnostic_slug}/values',
        ...options
    });
};

/**
 * Get Execution Statistics
 * Get execution statistics for the dashboard.
 *
 * Returns counts of total, successful, and failed execution groups,
 * plus recent activity count.
 */
export const executionsGetExecutionStatistics = <ThrowOnError extends boolean = false>(options?: Options<ExecutionsGetExecutionStatisticsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ExecutionsGetExecutionStatisticsResponse, unknown, ThrowOnError>({
        url: '/api/v1/executions/statistics',
        ...options
    });
};

/**
 * List Recent Execution Groups
 * List the most recent execution groups
 *
 * Supports filtering by:
 * - diagnostic_name_contains
 * - provider_name_contains
 * - dirty
 * - successful (filters by latest execution success)
 * - source_id (filters groups that include an execution whose datasets
 * include a CMIP6 dataset with this source_id)
 */
export const executionsListRecentExecutionGroups = <ThrowOnError extends boolean = false>(options?: Options<ExecutionsListRecentExecutionGroupsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ExecutionsListRecentExecutionGroupsResponse, ExecutionsListRecentExecutionGroupsError, ThrowOnError>({
        url: '/api/v1/executions/',
        ...options
    });
};

/**
 * Get
 * Inspect a specific execution
 */
export const executionsGet = <ThrowOnError extends boolean = false>(options: Options<ExecutionsGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ExecutionsGetResponse, ExecutionsGetError, ThrowOnError>({
        url: '/api/v1/executions/{group_id}',
        ...options
    });
};

/**
 * Execution
 * Inspect a specific execution
 *
 * Gets the latest result if no execution_id is provided
 */
export const executionsExecution = <ThrowOnError extends boolean = false>(options: Options<ExecutionsExecutionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ExecutionsExecutionResponse, ExecutionsExecutionError, ThrowOnError>({
        url: '/api/v1/executions/{group_id}/execution',
        ...options
    });
};

/**
 * Execution Datasets
 * Query the datasets that were used for a specific execution
 */
export const executionsExecutionDatasets = <ThrowOnError extends boolean = false>(options: Options<ExecutionsExecutionDatasetsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ExecutionsExecutionDatasetsResponse, ExecutionsExecutionDatasetsError, ThrowOnError>({
        url: '/api/v1/executions/{group_id}/datasets',
        ...options
    });
};

/**
 * Execution Logs
 * Fetch the logs for an execution result
 */
export const executionsExecutionLogs = <ThrowOnError extends boolean = false>(options: Options<ExecutionsExecutionLogsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, ExecutionsExecutionLogsError, ThrowOnError>({
        url: '/api/v1/executions/{group_id}/logs',
        ...options
    });
};

/**
 * Metric Bundle
 * Fetch a result using the slug
 */
export const executionsMetricBundle = <ThrowOnError extends boolean = false>(options: Options<ExecutionsMetricBundleData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ExecutionsMetricBundleResponse, ExecutionsMetricBundleError, ThrowOnError>({
        url: '/api/v1/executions/{group_id}/metric_bundle',
        ...options
    });
};

/**
 * Metric Values
 * Fetch metric values for a specific execution (both scalar and series)
 *
 * - `type`: Filter by metric value type - 'scalar', 'series', or 'all' (default)
 * - `format`: Return format - 'json' (default) or 'csv'
 */
export const executionsMetricValues = <ThrowOnError extends boolean = false>(options: Options<ExecutionsMetricValuesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, ExecutionsMetricValuesError, ThrowOnError>({
        url: '/api/v1/executions/{group_id}/values',
        ...options
    });
};

/**
 * Execution Archive
 * Stream a tar.gz archive of the execution results
 *
 * The archive is created on-the-fly and streamed directly to the client.
 */
export const executionsExecutionArchive = <ThrowOnError extends boolean = false>(options: Options<ExecutionsExecutionArchiveData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, ExecutionsExecutionArchiveError, ThrowOnError>({
        url: '/api/v1/executions/{group_id}/archive',
        ...options
    });
};

/**
 * Get Result
 * Fetch a result
 */
export const resultsGetResult = <ThrowOnError extends boolean = false>(options: Options<ResultsGetResultData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, ResultsGetResultError, ThrowOnError>({
        url: '/api/v1/results/{result_id}',
        ...options
    });
};

/**
 * Health Check
 */
export const utilsHealthCheck = <ThrowOnError extends boolean = false>(options?: Options<UtilsHealthCheckData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<UtilsHealthCheckResponse, unknown, ThrowOnError>({
        url: '/api/v1/utils/health-check/',
        ...options
    });
};