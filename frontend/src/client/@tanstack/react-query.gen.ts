// This file is auto-generated by @hey-api/openapi-ts

import { type Options, datasetsList, datasetsGet, datasetsExecutions, diagnosticsList, diagnosticsFacets, diagnosticsGet, diagnosticsListExecutionGroups, diagnosticsComparison, diagnosticsListExecutions, diagnosticsListMetricValues, executionsGetExecutionStatistics, executionsListRecentExecutionGroups, executionsGet, executionsExecution, executionsExecutionDatasets, executionsExecutionLogs, executionsMetricBundle, executionsMetricValues, executionsExecutionArchive, resultsGetResult, utilsHealthCheck } from '../sdk.gen';
import { queryOptions, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { DatasetsListData, DatasetsListError, DatasetsListResponse, DatasetsGetData, DatasetsExecutionsData, DatasetsExecutionsError, DatasetsExecutionsResponse, DiagnosticsListData, DiagnosticsFacetsData, DiagnosticsGetData, DiagnosticsListExecutionGroupsData, DiagnosticsComparisonData, DiagnosticsListExecutionsData, DiagnosticsListMetricValuesData, ExecutionsGetExecutionStatisticsData, ExecutionsListRecentExecutionGroupsData, ExecutionsListRecentExecutionGroupsError, ExecutionsListRecentExecutionGroupsResponse, ExecutionsGetData, ExecutionsExecutionData, ExecutionsExecutionDatasetsData, ExecutionsExecutionLogsData, ExecutionsMetricBundleData, ExecutionsMetricValuesData, ExecutionsExecutionArchiveData, ResultsGetResultData, UtilsHealthCheckData } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const datasetsListQueryKey = (options?: Options<DatasetsListData>) => createQueryKey('datasetsList', options);

export const datasetsListOptions = (options?: Options<DatasetsListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await datasetsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: datasetsListQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = queryKey[0];
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const datasetsListInfiniteQueryKey = (options?: Options<DatasetsListData>): QueryKey<Options<DatasetsListData>> => createQueryKey('datasetsList', options, true);

export const datasetsListInfiniteOptions = (options?: Options<DatasetsListData>) => {
    return infiniteQueryOptions<DatasetsListResponse, DatasetsListError, InfiniteData<DatasetsListResponse>, QueryKey<Options<DatasetsListData>>, number | Pick<QueryKey<Options<DatasetsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<DatasetsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await datasetsList({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: datasetsListInfiniteQueryKey(options)
    });
};

export const datasetsGetQueryKey = (options: Options<DatasetsGetData>) => createQueryKey('datasetsGet', options);

export const datasetsGetOptions = (options: Options<DatasetsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await datasetsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: datasetsGetQueryKey(options)
    });
};

export const datasetsExecutionsQueryKey = (options: Options<DatasetsExecutionsData>) => createQueryKey('datasetsExecutions', options);

export const datasetsExecutionsOptions = (options: Options<DatasetsExecutionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await datasetsExecutions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: datasetsExecutionsQueryKey(options)
    });
};

export const datasetsExecutionsInfiniteQueryKey = (options: Options<DatasetsExecutionsData>): QueryKey<Options<DatasetsExecutionsData>> => createQueryKey('datasetsExecutions', options, true);

export const datasetsExecutionsInfiniteOptions = (options: Options<DatasetsExecutionsData>) => {
    return infiniteQueryOptions<DatasetsExecutionsResponse, DatasetsExecutionsError, InfiniteData<DatasetsExecutionsResponse>, QueryKey<Options<DatasetsExecutionsData>>, number | Pick<QueryKey<Options<DatasetsExecutionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<DatasetsExecutionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await datasetsExecutions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: datasetsExecutionsInfiniteQueryKey(options)
    });
};

export const diagnosticsListQueryKey = (options?: Options<DiagnosticsListData>) => createQueryKey('diagnosticsList', options);

export const diagnosticsListOptions = (options?: Options<DiagnosticsListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await diagnosticsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: diagnosticsListQueryKey(options)
    });
};

export const diagnosticsFacetsQueryKey = (options?: Options<DiagnosticsFacetsData>) => createQueryKey('diagnosticsFacets', options);

export const diagnosticsFacetsOptions = (options?: Options<DiagnosticsFacetsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await diagnosticsFacets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: diagnosticsFacetsQueryKey(options)
    });
};

export const diagnosticsGetQueryKey = (options: Options<DiagnosticsGetData>) => createQueryKey('diagnosticsGet', options);

export const diagnosticsGetOptions = (options: Options<DiagnosticsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await diagnosticsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: diagnosticsGetQueryKey(options)
    });
};

export const diagnosticsListExecutionGroupsQueryKey = (options: Options<DiagnosticsListExecutionGroupsData>) => createQueryKey('diagnosticsListExecutionGroups', options);

export const diagnosticsListExecutionGroupsOptions = (options: Options<DiagnosticsListExecutionGroupsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await diagnosticsListExecutionGroups({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: diagnosticsListExecutionGroupsQueryKey(options)
    });
};

export const diagnosticsComparisonQueryKey = (options: Options<DiagnosticsComparisonData>) => createQueryKey('diagnosticsComparison', options);

export const diagnosticsComparisonOptions = (options: Options<DiagnosticsComparisonData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await diagnosticsComparison({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: diagnosticsComparisonQueryKey(options)
    });
};

export const diagnosticsListExecutionsQueryKey = (options: Options<DiagnosticsListExecutionsData>) => createQueryKey('diagnosticsListExecutions', options);

export const diagnosticsListExecutionsOptions = (options: Options<DiagnosticsListExecutionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await diagnosticsListExecutions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: diagnosticsListExecutionsQueryKey(options)
    });
};

export const diagnosticsListMetricValuesQueryKey = (options: Options<DiagnosticsListMetricValuesData>) => createQueryKey('diagnosticsListMetricValues', options);

export const diagnosticsListMetricValuesOptions = (options: Options<DiagnosticsListMetricValuesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await diagnosticsListMetricValues({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: diagnosticsListMetricValuesQueryKey(options)
    });
};

export const executionsGetExecutionStatisticsQueryKey = (options?: Options<ExecutionsGetExecutionStatisticsData>) => createQueryKey('executionsGetExecutionStatistics', options);

export const executionsGetExecutionStatisticsOptions = (options?: Options<ExecutionsGetExecutionStatisticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await executionsGetExecutionStatistics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: executionsGetExecutionStatisticsQueryKey(options)
    });
};

export const executionsListRecentExecutionGroupsQueryKey = (options?: Options<ExecutionsListRecentExecutionGroupsData>) => createQueryKey('executionsListRecentExecutionGroups', options);

export const executionsListRecentExecutionGroupsOptions = (options?: Options<ExecutionsListRecentExecutionGroupsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await executionsListRecentExecutionGroups({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: executionsListRecentExecutionGroupsQueryKey(options)
    });
};

export const executionsListRecentExecutionGroupsInfiniteQueryKey = (options?: Options<ExecutionsListRecentExecutionGroupsData>): QueryKey<Options<ExecutionsListRecentExecutionGroupsData>> => createQueryKey('executionsListRecentExecutionGroups', options, true);

export const executionsListRecentExecutionGroupsInfiniteOptions = (options?: Options<ExecutionsListRecentExecutionGroupsData>) => {
    return infiniteQueryOptions<ExecutionsListRecentExecutionGroupsResponse, ExecutionsListRecentExecutionGroupsError, InfiniteData<ExecutionsListRecentExecutionGroupsResponse>, QueryKey<Options<ExecutionsListRecentExecutionGroupsData>>, number | Pick<QueryKey<Options<ExecutionsListRecentExecutionGroupsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ExecutionsListRecentExecutionGroupsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await executionsListRecentExecutionGroups({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: executionsListRecentExecutionGroupsInfiniteQueryKey(options)
    });
};

export const executionsGetQueryKey = (options: Options<ExecutionsGetData>) => createQueryKey('executionsGet', options);

export const executionsGetOptions = (options: Options<ExecutionsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await executionsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: executionsGetQueryKey(options)
    });
};

export const executionsExecutionQueryKey = (options: Options<ExecutionsExecutionData>) => createQueryKey('executionsExecution', options);

export const executionsExecutionOptions = (options: Options<ExecutionsExecutionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await executionsExecution({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: executionsExecutionQueryKey(options)
    });
};

export const executionsExecutionDatasetsQueryKey = (options: Options<ExecutionsExecutionDatasetsData>) => createQueryKey('executionsExecutionDatasets', options);

export const executionsExecutionDatasetsOptions = (options: Options<ExecutionsExecutionDatasetsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await executionsExecutionDatasets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: executionsExecutionDatasetsQueryKey(options)
    });
};

export const executionsExecutionLogsQueryKey = (options: Options<ExecutionsExecutionLogsData>) => createQueryKey('executionsExecutionLogs', options);

export const executionsExecutionLogsOptions = (options: Options<ExecutionsExecutionLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await executionsExecutionLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: executionsExecutionLogsQueryKey(options)
    });
};

export const executionsMetricBundleQueryKey = (options: Options<ExecutionsMetricBundleData>) => createQueryKey('executionsMetricBundle', options);

export const executionsMetricBundleOptions = (options: Options<ExecutionsMetricBundleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await executionsMetricBundle({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: executionsMetricBundleQueryKey(options)
    });
};

export const executionsMetricValuesQueryKey = (options: Options<ExecutionsMetricValuesData>) => createQueryKey('executionsMetricValues', options);

export const executionsMetricValuesOptions = (options: Options<ExecutionsMetricValuesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await executionsMetricValues({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: executionsMetricValuesQueryKey(options)
    });
};

export const executionsExecutionArchiveQueryKey = (options: Options<ExecutionsExecutionArchiveData>) => createQueryKey('executionsExecutionArchive', options);

export const executionsExecutionArchiveOptions = (options: Options<ExecutionsExecutionArchiveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await executionsExecutionArchive({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: executionsExecutionArchiveQueryKey(options)
    });
};

export const resultsGetResultQueryKey = (options: Options<ResultsGetResultData>) => createQueryKey('resultsGetResult', options);

export const resultsGetResultOptions = (options: Options<ResultsGetResultData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resultsGetResult({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resultsGetResultQueryKey(options)
    });
};

export const utilsHealthCheckQueryKey = (options?: Options<UtilsHealthCheckData>) => createQueryKey('utilsHealthCheck', options);

export const utilsHealthCheckOptions = (options?: Options<UtilsHealthCheckData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await utilsHealthCheck({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: utilsHealthCheckQueryKey(options)
    });
};